# Chapter4_중앙처리장치

4.1  중앙처리장치 구조
---

### 4.1.1 제어장치 

**제어장치 기능**
>순서 제어(sequence control): 명령어 사이클 진행 - 명령어를 차례대로 실행  
>동작 제어(operation control): 제어신호 생성 -명령어 자체를 실행  


**제어장치 입출력**  
입력  
>명령어 레지스터(IR): 현재 실행하고 있는 명령어를 구별  
>상태 레지스터(SR): 명령어 실행 조건 검사하여, 조건 정보 구하기  
> 클럭 신호: 명령어 사이클을 진행하기 위한 타이밍 신호를 생성  

출력  
> 제어 신호: 컴퓨터의 구성 요소를 구동하는 제어 신호를 생성한다.

IR, SR, 클럭 신호를 받아서, 제어 신호를 생성(출력)한다.

### 4.1.2 처리장치
레지스터
>* 중앙처리장치 내부 기억장치: 주소와 데이터 임시 저장
>* 제어용 레지스터: 사용자에게 보이지 않는 레지스터(user non-visible reg.)
>* 명령어 실행용 레지스터 : 사용자에게 보이는 레지스터(user visible reg.)

연산기
>* 데이터 처리 담당
>* 제어신호는 연산기의 동작 결정
>* 연산 후 상태를 상태 레지스터에 저장

4.2  레지스터
---
### 4.2.1 제어용 레지스터
프로세서(중앙처리장치)가 프로그램을 진행하는데 사용하는 레지스터  

프로그램 카운터(PC)
>*  다음에 실행할 명령어가 저장된 기억장치 주소

명령어 레지스터(IR)
>* 현재 실행 중인 명령어

기억장치 주소 레지스터(MAR, Memory Address Register)
>* 기억장치 주소 저장
>* 주소 버스에 연결

기억장치 버퍼 레지스터(MBR, Memory Buffer Register)
>* 기억 장소의 데이터를 저장한 후, 목적지 레지스터로 옮김
>*  데이터 버스에 연결

PC가 주소버스에 연결되어 있지 않기 때문에, PC값이 직접 기억장치 주소로 인가될 수 없음. 명령어 인출단계는 이전 페이지를 참고할 것.

데이터읽기
1) MAR<- 주소 레지스터
2) MBR<-Mem[MAR]
3) 데이터 레지스터 <-MBR


데이터 쓰기
1) MAR <- 주소 레지스터
2) MBR <- 데이터 레지스터
3) Mem[MAR]<-  MBR

### 4.2.2 상태레지스터

상태 레지스터
>* 각 비트별로 의미를 가지며, 각 비트를 깃발이라는 의미(1과 0으로만 나타낼 수 있으므로) 플래그(flag)라고 부름.

플래그 종류
>* 조건 플래그(conditional flags) : 연산 결과 반영
>*  제어 플래그(control flags) :중앙처리장치 동작 제어

조건 플래그
>* 부호 (S, sign flag) - 양수면 0, 음수면 1
>*  제로 (Z, zero flag) - 연산결과가 0이 아니면 0, 연산결과가 0이면 1
>* 자리올림수 (C, carry flag) - 덧셈에서 자리올림수 발생시 1
>* 패리티 (P, parity flag) - 1의 개수아 짝수면 0,홀수면 1
>* 오버플로우 (OV, overflag flag) - 오버플로우 발생 경우 1

제어 플래그
>* 인터럽트 (IE, Interrupt Enable flag)
>* 운영체제 (SV, supervisor mode flag)


### 4.2.3 명령어 실행용 레지스터
초기의 컴퓨터는 데이터 레지스터를 하나만 갖고 있었고, 누산기라고 부름.

데이터 레지스터 (Data Register)
>* 중앙처리장치가 처리하는 데이터 임시 저장
>* 누산기 (accumulator)

주소 레지스터 (Address Register)
>* 기억장치 주소 저장
>* 중앙처리장치는 기억장치를 다양한 방법으로 액세스 한다.
>* 스택 포인터, 베이스 레지스터, 인덱스 레지스터

범용 레지스터 (General Purpose Register)
>* 데이터 레지스터 + 주소 레지스터
>* 통상 8 개 ~ 32 개


주소 레지스터
>* 포인터(pointer)를 주소 레지스터라고 부르기도 함.
>*  레지스터에 기억장치 주소를 저장하면, 명령어 길이가 짧아진다.

기억장치 용량이 64K바이트고, 범용 레지스터가 32개 일때,
>*  명령어에 기억장치 주소를 표현하기 위한 비트 수는? 64k = 2^16로, 16비트가 필요함. 
>*  명령어에 레지스터 중 하나를 표현하기 위한 비트 수는? 32 = 2^5로, 5비트가 필요함.

### 4.2.4 스택 포인터
스택(stack) : Last-In-First-Out: 데이터를 쌓아 두었다가, 마지막에 들어간 데이터부터 사용

SP (Stack Pointer) : 시스템 스택의 탑(top)을 가리키는 레지스터


스택의 데이터 크기 = 레지스터 크기 = 데이터버스 폭
스택은 단어 단위로 데이터 액세스됨. 

PUSH 오퍼랜드:  
SP ← SP - [단어 크기]  
Mem[SP] ← 오퍼랜드  

POP 오퍼랜드:   
오퍼랜드 ← Mem[SP]  
SP ← SP + [단어 크기]  


### 4.2.5 베이스 레지스터
베이스 레지스터 (Base Register): 스택의 기준점

### 4.2.6 인덱스 레지스터
인덱스 레지스터 (Index Register)
>* 연속적으로 저장되어 있는 데이터(배열) 액세스
>* 자동 인덱싱 : 인덱스 레지스터의 값을 자동으로 증가/감소

### 4.2.7 프로세서 레지스터

4.3 인터럽트
---
컴퓨터 내부 또는 외부에서 발생하는 갑작스러운 사건에 대응하는 기능

### 4.3.1 인터럽트 개념
인터럽트(interrupt) 과정 
>* 인터럽트 요청
>* 인터럽트 확인
>* 상태 저장
>* 인터럽트 서비스
>* 인터럽트 서비스에서 복귀

강의 도중에 학생이 질문(인터럽트요청)  
강사는 설명을 잠시 멈춤(상태 저장)  
질문에 답변(인터럽트 서비스)  
질문 전에 강의하던 내용으로 돌아와 강의를 진행(인터럽트 복귀)  

인터럽트는 내부 인터럽트와, 외부 인터럽트로 나뉜다.  
내부 인터럽트
>* 하드웨어 고장
>* 실행할 수 없는 명령어 
>* 명령어 실행 오류: 0으로 나누기
>* 사용 권한 위배

외부 인터럽트 - 주로 입출력 장치에 의해 발생. 
>* 타이머 인터럽트
>* 입출력 인터럽트

인터럽트 처리 과정
>* 인터럽트 요청
>*  인터럽트 확인
>*  상태 저장
>*  인터럽트 서비스
>*  인터럽트 복

인터럽트 단계
>* Context(PC와 SR)을 스택에 저장
>* Interrupt source를 확인하고, ISR의 시작 주소 확인

인터럽트 리턴
>* 인터럽트 서비스 루틴의 마지막 실행 명령어 (Return from Interrupt)


### 4.3.3 인터럽트 가능 플래그
컴퓨터의 상태 변화
>* 컴퓨터 전원 인가 후, 인터럽트에 허용하게 하는 3가지 사항
>* 시스템 스택 설정
>* 인터럽트 서비스 루틴을 기억장치에 적재
>*  인터럽트 벡터 테이블 설정
>* 인터럽트 벡터 : 인터럽트 서비스 루틴의 주소
>* 인터럽트 벡터 테이블 : 여러 가지 인터럽트에 대한 인터럽트 벡터 모음

IE flag(인터럽트 가능 플래그)
>* 상태 레지스터에 있는 제어 플래그 중 하나
>* 중앙처리장치가 인터럽트를 허용할지 제어

인터럽트 제어
IE Flag 제어 명령어
>* STI (Set Interrupt Flag)
>* CLI (Clear Interrupt Flag)

임계 영역 (critical section)
>* 프로그램 중 실행이 중단되었다가 다시 시작되면 문제가 발생하는 영역
>* IE 제어 명령어로 보호한다.

4.3.4 인터럽트 서비스 루틴
인터럽트 서비스 루틴(ISR, Interrupt Service Routine)
>* 인터럽트 요청을 해결하는 프로그램

인터럽트 처리 순서
>* 프로그램 실행 중
>* 인터럽트 요청
>* 인터럽트 단계
>> 인터럽트 확인  
>> 콘텍스트 저장  
>> PC <- ISR 주소
>* 인터럽트 서비스 루틴 실행
>* 인터럽트 리턴
>> 콘텍스트 복구
>* 중단된 프로그램 다시 시작

4.4 명령어 사이클
---
명령어 사이클의 기본 구성: 인출 단계/실행 단계/인터럽트 단계

프로세서마다 명령어 사이클의 실행 단계를 세분화
>* 해독 단계(decode stage): 명령어 코드를 해석
>* 기록 단계(write stage): 명령어 실행 결과를 레지스터나 기억장치로 저장
>* 간접 단계(indirect stage): 기억장치에서 데이터 인출