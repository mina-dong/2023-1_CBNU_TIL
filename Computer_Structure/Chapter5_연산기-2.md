# Chapter5_연산기 -2 (ALU)


5.4 시프트 연산
---

시프트 (shift) 연산 : 왼쪽이나 오른쪽으로 한 비트씩 자리 이동

### 5.4.1 논리시프트(logical shift)
* 왼쪽 논리시프트: SHL R1 // 한 비트씩 왼쪽으로 자리이동
* 오른쪽 논리시프트: SHR R1 // 한 비트씩 오른쪽으로 자리이동
* 새로 채워지는 비트의 값은 0
* 제거되는 비트는 상태 레지스터의 Carry 플래그에 저장



### 5.4.2 산술시프트(arithmetic shift)
* 왼쪽 산술시프트: ASL R1 // R1 <- R1*2. 왼쪽에 0을 채움
* 오른쪽 산술시프트: ASR R1 // R1 <- R1/2. 부호 비트를 채움
* 부호 비트는 고정

###  5.4.3 회전
밀려나가는 비트가 반대 방향의 끝에 채워지는 연산


5.5 산술 연산
---
해당 부분은 꼭 아래 하단의 예제풀이관련 링크를 참고할 것.

양수, 음수를 구분하지 않는다.

### 5.5.1 단항 연산
* NEG R // R ← –R (2의 보수)
* INC R // R ← R+1 (증가)
* DEC R // R ← R-1 (감소)

### 5.5.2 덧셈과 뺄셈
* 덧셈: ADD R1, R2 // R1 ← R1+R2
* 뺄셈: SUB R1, R2 // R1 ← R1–R2 = R1 + (R2에 대한 2의 보수

**오버플로우**
연산 결과가 수의 표현 범위를 초과하는 현상


### 5.5.3 곱셈
n비트 곱셈
* aⅹb = 곱 (product, 2n 비트)
* a: 피승수(multiplicand), b: 승수(multiplier)


### 5.5.4 나눗셈
2n 비트 / n 비트 나눗셈 = n 비트 몫 … n 비트 나머지
*  a/b = 몫 (quotient) … 나머지(remainder)
*  a: 피젯수(dividend), b: 젯수(divisor)

5.6 실수
---

### 5.6.1 부동 소수점 표현
10진수 과학 표기 예
* 976,000,000,000 = 9.76ⅹ1011 부호: + 가수: 9.76 지수: 11
*  –0.00000000000976 = -9.76ⅹ10–12 부호: – 가수: 9.76 지수: –12

2진수 예)  
* 0.1101ⅹ2^2 = 11.010ⅹ2^0 = 110.10ⅹ2^–1

**정규화(normalize) 필요**

### 가수정규화(normalized mantissa)
* (1.bbb…b ⅹ 2E) 형식이 되도록 지수 조정
* 1.은 표현에서 생략 (항상 1.0은 있는 것으로 취급)
* 가수를 표현하는 비트 영역 최대 활용
* 숫자 0은 모든 비트를 0으로 채움

### 바이어스 지수(biased exponent)
*  표현 = 지수 + bias // 지수를 양수로 변환
* 실제 지수 = 표현 – bias
* 예) 지수 영역이 8비트일 때, bias = 12710 = 0111_1111
* 이유? 덧셈 뺄셈을 할 때, 양수 영역에서 지수를 비교하기 위하여

### 5.6.2 IEEE754 형식

컴퓨터마다 호환하는게 다르다 보니, IEEE에서 지정한 표준안으로 제일 많이 사용하는 형식임. 

예제풀이 및 참고링크
https://min-develop.blogspot.com/2023/05/chapter5-2-alu.html
