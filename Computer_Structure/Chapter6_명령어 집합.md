# Chapter6_명령어 집합


6.1 명령어 특성
---
명령어 구성 요소: 동작코드 + 오퍼랜드

**동작코드(opcode, operation code)**
* 중앙처리장치가 실행할 동작을 2진수로 표현한 코드
* 니모닉 코드(mnemonic code): 의미를 나타내는 기호 코드
* 예) ADD, SUB, MUL, DIV, BR, PUSH, POP

**오퍼랜드(operand)**
* 동작의 대상: 소스 오퍼랜드, 목적지 오퍼랜드, 분기목적지 주소
* 실제: 레지스터 번호, 기억장치 주소, 입출력 포트

  
### 6.1.2 명령어 종류
**명령어 종류**
* 데이터 전달 명령어: A <- B
* 데이터 처리 명령어: A <- B op C
* 프로그램 제어 명령어: PC <- 목적지 주소

### 6.1.3 명령어 형식
명령어 형식
* 명령어 비트 영역에 명령어 구성 요소를 배치한 형태
* 동작 코드 필드, 오퍼랜드 필드

프로세서의 명령어 형식: 고정 길이/가변 길이 명령어 형식

**고정 길이 (fixed-length) 명령어 형식**
* 명령어의 길이가 모두 같다.
*  해석이 쉽고, 제어장치가 간단하다.

**가변 길이 (variable-length) 명령어 형식**
* 명령어 종류별로 길이가 다르다.
*  해석이 어렵고, 제어장치가 복잡하다.

명령어 형식에 영향을 주는 3가지 : 기억장치, cpu복잡도 및 속도, bus 구조

6.2 주소의 수
---
RISC(reduce instrvtion set computer): 신뢰가 중요하고, 엘리베이터 같은 곳에서 많이 쓰임.  
CISC (complex instrction se computer): PC, 메인프레임, 서버 같은 속도를 중요시 하는 분야에서 쓰임  

### 6.2.1.  3주소 명령어 형식
목적지 <- 소스1 op 소스2  

동작코드_목적지오퍼랜드_소스오퍼랜드1_소스오퍼랜드2  

Y = A*B + C*D
*   MUL R1, A, B // R1 <- A * B
*   MUL R2, C, D // R2 <- C * D
*   ADD Y, R1, R2 // Y<- R1 + R2

특징
*   오퍼랜드를 3개 모두 표현한다.
*   명령어 길이가 길어진다.
*  프로그램을 구현하는 명령어 수가 적다.
*  RISC 프로세서에서 주로 사용한다.


### 6.2.2 2주소 명령어 형식
동작코드_목적지/소 오퍼랜드_소스오퍼랜드  
목적지 <-  목적지 op 소스  

Y = A*B + C*D
*  LD R1, A // R1 <- A
*  MUL R1, B // R1 <- R1 ⅹ B
*  LD R2, C // R2 <- C
*  MUL R2, D // R2 <- R2 ⅹ D
*  ADD R1, R2 // R1<- R1 + R2
*  ST Y, R1 // Y <- R1

특징
* 소스 오퍼랜드 하나를 생략한다.
* 명령어 길이가 짧아진다.
* 프로그램을 구현하는 명령어 수가 증가한다.
* CISC 프로세서에서 주로 사용한다.

### 6.2.3 1주소 명령어 형식
동작코드_오퍼랜드

AC <- AC op 오퍼랜드  


Y = A*B + C*D
* LD A // AC <- A
*  MUL B // AC <- AC * B
*  ST T // T <- AC
* LD C // AC <- C
*  MUL D // AC <- AC * D
*  ADD T // AC <- AC + T
*  ST Y // Y<- AC


특징
* 누산기(AC)를 사용한다.
*  명령어 표현에서 누산기를 생략한다.
*  명령어의 길이가 짧다.
* 프로그램을 구현하는 명령어의 수가 가장 많다.
*  초기 컴퓨터에서 사용하였으나, 지금은 찾아보기 힘들다.

### 6.2.4 0주소 명령어 형식
특수 계산기에서 사용하는 명령어 형식

스택 연산
* 계산식 표현
* 후위 표기식: Y = A*B + C*D (중위표기식) => (Y = AB*CD*+) (후위표기식)

계산 과정
* 변수: PUSH Data // 데이터를 푸시
* 연산자: POP R1 // 두 개의 데이터를 팝하고
POP R2
R3 <- R1 op R2 // 계산 후
PUSH R3 // 결과를 푸시
* 계산 끝: POP Y // 계산 결과를 변수에 저장

3주소에서 1주소로 갈수록, 명령어가 점점 길어지는 것을 확인할 수 있다.

6.3 주소지정방식
---
**주소지정방식**
오퍼랜드 필드마다 별도 적용  

 **표기법**
* A: 명령어에 표현된 주기억장지 주소
*  Mem(A): 주기억장치 A 번지에 저장된 값
* R: 레지스터 번호
*  (R): 레지스터 R에 저장되어 있는 값
*  EA: 유효 주소(effective address). 유효 데이터가 저장되어 있는 기억장치 주소
  
### 6.3.1 즉치 주소지정방식
즉치 데이터(immediate data)
* 명령어에 유효 데이터 포함
* 명령어를 실행할 때 기억장치를 액세스할 필요가 없다.
* 유효 데이터의 표현 범위가 오퍼랜드 필드 크기에 제한 받는다
  
### 6.3.2 직접 주소지정방식
직접 주소지정방식 (direct addressing mode)
* 명령어에 기억장치 주소(A)가 표현된다. A는 부호 없는 수이다.
* 유효 주소 = A

### 6.3.3 간접 주소지정방식
간접 주소지정방식(indirect addressing mode)
*  명령어에 기억장치 주소를 표현한다.
*  A는 부호 없는 수이다.
*  A의 길이는 기억장치 주소의 길이와 같다.
*  유효 주소 = mem(A)
*  명령어 실행 단계에서 기억장치를 2번 액세스한다.
*  유효 주소 인출/유효 데이터 인출

### 6.3.4 레지스터 주소지정방식
레지스터 주소지정방식(register addressing mode)
* 명령어는 레지스터 번호 표현
*  유효 주소 개념이 없음.
*  R 필드이 길이는 주소(A) 필드 길이보다 많이 짧다

### 6.3.5 레지스터 간접 주소지정방식
레지스터 간접 주소지정방식(register indirect addressing mode)
* 명령어는 레지스터 번호를 표현
* 유효 주소 = (R)
* 유효 데이터 = mem((R))
* 실행단계에서 유효 데이터를 인출하기 위하여 기억장치를 한 번 액세스
* 명령어의 길이가 짧으면서, 기억장치를 액세스할 수 있다.

### 6.3.6 변위 주소지정방식
유효 주소 = (R) + A
부호 확장 덧셈 예
* 기억장치 주소: 16 비트 (기억장치 공간 64 Kbytes)
* 레지스터 길이: 16 비트
* 명령어 주소 필드 A: 12 비트
*  유효 주소 = (R)(16비트) + A(12비트)
  
종류  
* 상대 주소지정방식(relative addressing mode)
* 베이스 레지스터 주소지정방식(base-register addressing mode)
* 인덱싱(indexing)

**상대 주소지정방식(relative addressing mode)**
* 분기 목적지 = PC + A (정수, 부호 확장)
* (조건) 분기 명령어, 서브루틴 호출 명령어

**베이스 레지스터 주소지정방식(base-register addressing mode)**
* Base Register: 스택의 기준점 지정
* 유효 주소 = (BR) + A (정수, 부호 확장 계산)
* 기준점의 위 아래 액세스 가능


**인덱싱(indexing)**
* 분기 목적지 = PC + A (정수, 부호 확장)
* (조건) 분기 명령어, 서브루틴 호출 명령어

6.4 오퍼랜드 저장
---
### 6.4.1 데이터 정렬
기억장치 구성
* 기억장치: 바이트 단위 주소 지정
* 단어(word)는 n바이트에 분산
* 단어는 Mem[A+0] ~ Mem[A+(n-1)]번지에 연속적으로 저장되어 있음.

단어 크기에 정렬 (word-size aligned)
* n의 배수로 시작하는 주소에 배정
* 단어가 배정된 시작 주소 A는 n의 배수 (단, n=2k)
  
단어 액세스 방법
* 정렬된 n바이트 단어를 한 번에 액세스할 수 있다.
* 정렬되지 않은 단어는 두 번에 걸쳐 읽은 후 조합해야 한다.

[예제 6-9] 에 관한 설명은 하단 링크에 있음.

### 6.4.2 바이트 순서
바이트 순서(byte order)
* 한 개의 단어가 한 바이트 이상의 기억장치 공간을 차지할 때, 
* 단어를 구성하는 바이트를 주어진 공간에 배치하는 방법

Little endian
*  주소 값이 작은 장소에 무게가 작은 수 저장
* 예) Intel X86, ARM
  
Big endian
* 주소 값이 작은 장소에 무게가 큰 수 저장
* 예) Motorola 68XXX, MIPS, 인터넷

[예제 6-10] 관련 하단 링크.

6.5 명령어 종류
---
*  6.5.1 데이터 전달 명령어
*  6.5.2 입출력 명령어
*  6.5.3 산술 연산 명령어
*  6.5.4 논리 연산 명령어
*  6.5.5 데이터 변환 명령어
*  6.5.6 상태 레지스터 조작 명령어
*  6.5.7 분기 명령어
*  6.5.8 서브루틴 호출 명령어
*  6.5.9 인터럽트 명령어
*  6.5.10 시스템 제어 명령어
  
### 6.5.1 데이터 전달 명령어
적재(load): Reg <- Mem    
저장(store): Mem <- Reg    
이동(move): {Reg, Mem} <- {Reg, Mem}    
교환(exchange): {Reg or Mem}  {Reg or Mem}    
스택: PUSH REG, POP REG    


### 6.5.2 입출력 명령어
입력(input): Reg <- I/O port  
출력(output): I/O port <- Reg  
 
 일반적으로 직접주소지정방식 또는 레지스터 간접 주소지정방식을 사용한다. 복잡한 주소지정방식을 사용하지 않는다.

### 6.5.3 산술 연산 명령어
단항 연산 명령어: 절대값(absolute), 음수(negate), 증가(increment), 감소(decrement), 제곱근(square root)  

이항 연산 명령어 : 더하기, 빼기, 곱하기, 나누기  

데이터 형식: 부호 없는 수, 정수, 실수, 이진화 십진 코드(BCD)  
데이터 크기: 8, 16, 32, 64비트  

###  6.5.4 논리 연산 명령어
논리 이항 연산 명령어 : AND, OR, XOR /  NAND, NOR, XNOR  
논리 단항 연산 명령어 :NOT, Clear bit, Set bit, Shift( 논리 시프트, 산술 시프트, 회전)  

### 6.5.5 데이터 변환 명령어
데이터 형식 변환 명령어
* BCD ↔ Binary
* 비트 크기 변환: 8 비트 ↔ 16 비트 ↔ 32 비트
* 형식 변환: 정수 ↔ 단정도 실수 ↔ 배정도 실수
번역 (translation) 명령어
* 인덱싱 주소지정방식 활용
* Reg ← 표 참조
  
###  6.5.6 상태 레지스터 조작 명령어
Compare 명령어 compare A, B // A – B  
Test 명령어 test A, B // A AND B  

Set/reset carry flag 명령어
* stc (set carry flag)
* clc (clear carry flag)
Set/reset interrupt flag 명령어
*  sti (set interrupt flag)
*  cli (reset interrupt flag)

###  6.5.7 분기 명령어
오퍼랜드 = 분기 목적지 주소
* 직접 주소지정방식
* 레지스터 간접 주소지정방식
* 상대 주소지정방식
종류
* 무조건 분기 명령어: br / jmp
* 조건 분기 명령어
* Branch taken : PC <- 분기 목적지 주소
* Branch not taken : PC <- 다음 명령어 (변하지 않음)

[예제 6-11] 풀이 하단 링크

###  6.5.8 서브루틴 호출 명령어
call [서브루틴 시작 주소]
* PUSH PC
* PC <- 서브루틴 시작주소

ret
* POP PC //PC 복
### 6.5.9 인터럽트 명령어
소프트웨어 인터럽트, system call  

인터럽트 복귀 명령어  

###  6.5.10 시스템 제어 명령어
시스템 관리, 운영체제 기능 지원 명령어
* Halt 시스템 정지
* Wait 이벤트 대기
* Nop 클럭 소모
프로세서 동작 모드(operation mode)
* 시스템 모드(system mode, 커널 모드, 운영체제 모드)
* 사용자 모드(user mode)
특권 명령어(privileged instruction)
* 시스템 모드에서만 실행할 수 있는 명령어
* 특수 레지스터 관리, 기억장치 관리, 입출력 명령어 등




https://min-develop.blogspot.com/2023/06/cp6.html 