# Chapter3_컴퓨터 구성 요소

3.1 프로그램 실행
---
컴퓨터는 프로그램을 실행하는 기계임. 컴퓨터는 고급언어로 작성된 프로그램을 직접 실행할 수 없고, 컴퓨터가 실행할 수 있는 형태의 언어에 해당하는 기계어 프로그램을 실행할 수 있다. 컴파일러는 고급 언어로 작성된 프로그램을 컴퓨터가 이해할 수 있는 형태인 기계어 프로그램으로 번역한다.

### 3.1.1 기계어 프로그램
기계어 - 2진수로 코드화 되어 있어 사람이 알아보기 힘듦.  
-> 기계어와 일대일 대응하는 기호를 사용하여 프로그램을 작성하는 방법을 도입하며 편리를 도모함. 

기계어를 대신하는언어를 **어셈블리어**라고 함  
어셈블리어라고 작성된 프로그램 **어셈블리어 프로그램**이라고 함.  
어셈블리어를 기계어프로그램으로 번역하는 프로그램을 **어셈블러**라고 함.


### 3.1.2 프로그램 내장형 컴퓨터

1946년 폰 노이만이 프로그램 내장형 컴퓨터를 제안
>* 프로그램과 데이터를 주기억장치에 저장한다
>* 컴퓨터는 주기억장치에 저장되어있는 프로그램을 중앙처리장치에서 실행한다.
>
프로그램 내장형 컴퓨터는 중앙처리장치와 주기억 장치간의 통신 태널이 한개여서, 명령어와 데이터를 동시에 가져올 수 없다.  
-> 하버드구조 - 프로그램 기억장치와 데이터기억장치를 분리하면, 명령어와 데이터를 동시에 액세스 할 수있어 기억장치 액세스 속도를 개선할 수 있다.

**명령어사이클**
중앙처리 장치는 컴퓨터 전원이 인가된 후, 인출과 실행 단계를 전원이 꺼질 때까지 무한 반복됨.
이 과정을 명령어 사이클이라고 한다.
* 첫번재 사이클 : 인출
  > 주기억장치에 저장되어 있는명령어를 중앙처리장치에 가져옴

* 두번째 사이클 : 실행
  > 중앙처리장치는 명령어가 의미하는 동작을 해독하여여 수행함.

3.2 컴퓨터 구성 요소
---
중앙처리장치, 주기억장치, 입출력장치로 됨.  
이 세가지 구성요소를 시스템버스에 의해 연결됨.

### 3.2.1 중앙처리장치
명령어 사이클을 반복해서 수행함으로써, 프로그램을 실행함.
PC 프로그램 카운터, IR 명령어 레지스터 / 연산기, CU 제어장치, 내부 레지스터

1. 인출단계  
   명령어가 저장되어 있는 주기억장치의 주소를 저장할 레지스터와, 인출한 명령어를 저장할 레지스터가 필요함 (프로그램 내장형 컴퓨터가 명령어를 실행하려면 꼭 2가지 레지스터가 필요함.)

* PC 프로그램 카운터  
> 다음에 실행할 명령어의 주소를 기억함.

* IR 명령어 레지스터
> 현재 실행중인 명령어를 저장함.

레지스터 전송언어:  
IR <- Mem[PC],  PC <-PC +[명령어의 길이]

프로그램 카운터에 있는 명령어를 IR에다 저장함. 동시에, PC의 값을 다음 명령어를 가리키도록 증가시킴.

2. 실행단계
   IR에 이쓴 명령어를 해독하여 명령어를 실행함. 명렁어를 해독하는 장치를 **제어장치** 라고 함. 명령어를 처리하는 **내부레지스터**와 **연산기**를 필요로 함.

* CU 제어장치
  >IR에있는 명령어를 해독하고 **제어신호를 발생**시킴. 제어장치는 모든 제어신호를 생성함

* 내부 레지스터
  > 중앙처리장치가 명령어를 처리하기 위한 임시 기억장치

* 연산기 
  > 중앙처리장치 안에서 데이터를 처리하는 기능.
  

실행단계에서의 중앙처리장치가 처리하는 일은 3가지로 분류할 수 있다.  
데이터 전달, 데이터 처리, 프로그램 제어


### 3.2.2 주기억장치 (기억장치의 내부 구조와 동작 원리)
중앙처리장치가 처리해야 할 프로그램과 데이터를 저장한다. 주소에 내부 데이터를 액세스하는 거대한 1차원 배열이라고 생각할 수 있다.

* 주소선
  > 기억장치에 대한 입력 신호. 주소선이 n비트로 구성되어 있는 경우, 기억장치는 2^n개다.

* 데이터선
  > 기억장치에 대한 입력과 출력신호 작용. 한 개의 기억장소에 k비트의 데이터가 저장

* (읽기/쓰기) 제어선
 > 기억장치에 대한 입력신호

중앙처리장치는 다음과 같은 2가지 방법으로 기억장치를 액세스함.
* 적재(load)
  > 기억장치의 한 장소(address)에서 데이터를 읽어서 중앙처리장치의 레지스터로 가져옴.

* 저장(store)
  > 중앙처리장치의 레지스터에서 기억장치 한 장소에 데이터를 저장.
  

### 3.2.3 입출력장치(I/O)
외부에서 데이터를 받아처리하고, 그 결과를 외부로 제공함.

입력장치 - 키보드,마우스,마이크,카메라 등  
출력장치 - 모니터, 프린터, 스피커  
입출력장치 - 보조기억장치,네트워크 어탭터  

**입출력장치의 구조**
입출력모듈
> 인터페이스 - 동작방식, 데이터전송속도, 데이터형식조정
> 신호변환기 - 전기신호를 기계 동작으로 변환 또는 반대 변환 수행

기계장치(동작부)
> 입출력장치고유기능, 기계 구동

주소선
> 주소선디코드, 입출력포트선택

데이터선
> 중앙처리장치와 데이터선을 통해 데이터를 주고받음

제어선
> 동작을 제어하기 위해 읽기 쓰기 제어신호 사용함.

### 3.2.4 AVR 마이크로제어기
하나의 칩에 중앙처리장치, 기억장치, 주변장치를 포함한 반도체 소자.
소형시스템의 제어장치로 쓰임.

3.3 시스템 버스
---
세 가지 구성요소를 연결하는 신호선들의 모임

### 3.3.1 시스템 버스구성 
주소버스
> 기억장치 또는 입출력장치의 주소를 지정한다
> 기억장치 용량과 관련이 있다

데이터버스
> 데이터를 전달하는 경로. 데이터 버스 폭은 8의 배수.
> 레지스터의 크기 = 단어 크기

제어 버스
> 주소 버스와 데이터버스를 제외한 나머지 신호선을 모은 것
> 각 비트별로 고유한 기능을 가짐.


### 3.3.2 제어 신호 종류
기억장치 제어
>기억장치 읽기 (memory read)
>기억장치 쓰기 (memory write)

입출력장치 제어
>입출력 읽기 (input 또는 I/O read)
>입출력 쓰기 (output 또는 I/O write)
>인터럽트 요청 (interrupt request)
>인터럽트 확인 (interrupt acknowledge)
>버스 요청 (bus request)
>버스 승인 (bus grant)
>기타

시스템 클럭 (system clock)
>리셋 (reset)
>전력선 (power lines)

### 3.3.3 버스 계층
버스 계층:
>버스 경쟁 완화
>시스템 버스: 지역 버스, 고속 버스
>입출력 버스: 확장 버스, 저속 버스, 장치 버스

3.4 명령어
---
프로그램은 명령어들의 집합임.

### 3.4.1 명령어의 구성 요소
명령어 - 하드웨어와 소프트웨어가 만나는 부분,컴퓨터가 수행할 일을 2진수 코드로 표현

구성 요소 -   동작 코드(opcode, operation code) /  동작의 대상(operand): 최대 3개

명령어 형식 - 명령어에 포함된 정보를 2진수에 배치한 형태 / 
 전체 길이, 필드 구성과 의미, 각 필드의 비트 수

### 3.4.2 명령어의 종류

동작을 나타내는 부분 - 동작코드
동작의 대상 - 오퍼랜드(또는 피연산자)

데이터 전달 명령어 (data transfer instructions):
>내부 레지스터, 주기억장치, 입출력장치 간 데이터 전달 (복사)

데이터 처리 명령어 (data process instructions):
>내부 레지스터 또는 주기억장치의 데이터를 연산기에서 조작

프로그램 제어 명령어 (program control instructions):
>프로그램 실행 순서 변경

```
int n = 1; // 데이터 전달
int sum = 0; // 데이터 전달

while (n <= 100) { // 프로그램 제어
sum = sum + n; // 데이터 처리
n = n + 1; // 데이터 처리
} 
```

**데이터 전달 명령어**  
적재(load): Register <- Mem[address]  
저장(store): Mem[address] <- Register  
이동(move): {Register, Mem[address]} <- {Register, Mem[address]}  
입력(input): Register <- I/O Port[address]  
출력(output): I/O Port[address] <- Register 

**데이터 처리 명령어**
단항 연산 처리 명령어
>목적지 = op 소스  
>Negate (음수, 부호 변경)  
>Not, Shift  
>증가, 감소  

이항 연산 명령어
>목적지 = 소스1 op 소스2  
>소스 오퍼랜드 한 개 생략 가능:  
>목적지 = 목적지 op 소스  
>사칙 연산: +, -, ⅹ,   
>논리 연산: AND, OR, XOR

**데이터 제어 명령어**  
무조건 분기: PC <- [분기 주소]  
조건 분기: if (조건) PC <- [분기 주소]  
서브루틴 호출: PC 저장 / PC <- [서브루틴 시작 주소]  
서브루틴 복귀: PC <- [저장된 주소] 

### 3.4.3 오퍼랜드
오퍼랜드 (operand, 피연산자)
>명령어가 처리하려는 동작의 대상

유효 데이터 (effective data)
>중앙처리장치가 실제로 처리하는 데이터  
>크기가 정해진 2진수 형태 (예: 8 비트, 16 비트, 32 비트)  

오퍼랜드 유형
>즉시 데이터(immediate data): 명령어가 유효 데이터를 포함한다.  
>레지스터 이름: 레지스터의 값이 유효 데이터.  
>기억장치 주소: 기억장치 해당 주소의 값이 유효 데이터.  
>입출력 포트: 입출력 포트의 값이 유효 데이터


유효데이터 해석방법
>부호 없는 수 (unsigned number): 부호가 없는 정수로 해석되는 데이터 형태  
>정수 (signed number): 부호가 있는 정수로 해석되는 데이터 형태  
>실수 (floating-point number): 부동 소수점 형태로 해석되는 데이터 형태  
>문자 코드: 문자에 대한 코드로 해석되는 데이터 형태  

명령어와 오퍼랜드의 관계
>명령어에 따라 유효 데이터를 해석하는 방법이 다르다.  
>길이, 해석 방법이 다르면 명령어의 동작 코드도 달라야 한다.

3.5 명령어 실행 과정
---
### 3.5.1 프로그래머 모델
 어셈블러 프로그래머가 프로그램을 작성하기 위하여 알고 있어야 할 컴
퓨터 구조

ToyCOM 명령어 형식 
명령어 종류  
> 데이터 이동 명령어, 데이터 처리 명령어  
>프로그램 제어 명령어는 고려하지 않는다.

오퍼런드
> 부호 없는 8 비트 데이터만 고려한다.

명령어 집합
| 명령어 | 동작 코드 | 동작 설명 |
|--------|----------|----------|
| LOAD   | 0010     | 레지스터나 기억장치로부터 데이터를 로드(복사)한다. |
| STORE  | 0011     | 레지스터나 기억장치에 데이터를 저장(복사)한다. |
| ADD    | 1000     | 레지스터나 기억장치에 데이터를 더한다. |
| SUB    | 0101     | 레지스터나 기억장치에서 데이터를 뺀다. |
| AND    | 1010     | 레지스터나 기억장치의 데이터와 논리 AND 연산을 수행한다. |
| OR     | 1011     | 레지스터나 기억장치의 데이터와 논리 OR 연산을 수행한다. |

